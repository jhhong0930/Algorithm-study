# 1주차 알고리즘 스터디 정리

## 1. 로또의 최고 순위와 최저 순위

❤ Greedy 알고리즘을 활용

1) 0의 갯수 세기
2) 입력과 기준(lottos,win_nums)을 비교해서 일치하는 갯수 세기
3) 0의 갯수가 0개이면 최저와 최고순위가 동일
4) 3)이 아니라면, "최고순위"만 달라질 것
▶ min : 추가 점수가 없을 때 → arr[1], max: 추가 점수가 있을 때→arr[0]
→ 이렇게 된 이유는 [최고순위, 최저순위] 순으로 보여야 하기 때문

## 2. 신규 아이디 추천

❤ 단계별로 접근

1) 대문자를 소문자로 변경
2) 'a'~'z', 숫자, '-','_','.'는 결과문자열에 더하기
3) 연속된 '.'는 ".." 혹은 "..."과 같은데, str.replace를 이용해서 해당 패턴이 나오면 "."로 변경
4) startsWith, endsWith를 이용해서 처음과 끝의 "."을 인식해서 제거
5) 결과가 빈 문자열이면 "a"를 덧붙이기
6) 길이가 16이상이면 부분문자열 substring을 이용해서 인덱스 15까지 제한시키기
7) 6)을 해도 "."이 남는 케이스가 존재해서[abcdefghijklmn.p] endsWith로 다시한번 마지막
"."을 제거

8) 길이가 2 이하면 마지막 문자를 계속해서 더하기(결과 문자열에)

## 3. 숫자 문자열과 영단어

- 영어로 표현된 숫자를 숫자로 변경하는 문제

1) ["zero",...,"nine"] 배열 만들기
2) for 문으로 입력을 확인하면서 1)의 배열과 일치하는 경우는 replace
3) 2) 결과를 Integer로 파싱해서 리턴

## 4. 키패드 누르기

처음 시도할 때에는 bfs로 시도했지만, 고려해야 할 케이스가 너무 많아서
규칙성을 찾아서 접근했습니다

- 수직은 3차이, 수평은 1차이가 나는 거리로 간주

1) 왼쪽이든 오른쪽이든 제곱근거리로 생각하지 말고 수평거리+수직거리로 생각
2) |목표키-루트키|/3+|목표키-루트키|%3을 왼쪽, 오른쪽 손기준으로 계산
 *는 10으로 #은 12 로, 0은 11로 간주
3) 1,4,7은 왼손으로
4) 3,6,9는 오른손으로
5) 2)는 중간키들에 한해서 진행하고, 만약 그 거리값이 왼쪽과 오른쪽이 같으면 
주로 사용하는 손(hand)에 따라 결정해주기
공통) 단, 왼손으로 진행하면 루트를 numbers[i]로, 오른손도 마찬가지로 변경해주기!

## 5. 크레인 인형뽑기 게임

4번 문제에 시간을 빼앗기다 보니 5번은 그림만 봐도 힘들어서
처음에는 잘 안봤었는데.. 천천히 보니까 그림으로 이해해보면
스택을 이용하면 될 것 같아서 스택구조를 이용하였다

1) 어차피 0이 빈칸이니 처음에 0을 넣고
2) moves배열만큼 반복하는데, 그 내부에서는 boards배열의 행 길이만큼 반복시켜서
boards배열의 각 열에서도 위에서부터 내려가는 식으로 마치 스택처럼 바라본다
3) peek()로 스택의 맨 윗값과 boards에서 moves로 참고한 값이 같으면 pop과 동시에 2개를
증가(2개씩 비교)
4) boards에서 moves로 참고한 값은 더이상 보지 않아도 되므로 0으로 빈칸처리 후 break
