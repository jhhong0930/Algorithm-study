# algorithm-study
각자 이름으로 브렌치 만드신 후 해당 주차 스터디 진행 전까지 푸시 하시면 됩니다  

## 2주차 문제 풀이

- 2주차 과정 외에 풀고 싶은 문제들도 기록하였습니다

### 1. 음양더하기

- true면 양수 false면 음수인데 true면 더하고 false면 빼는 식으로 생각

### 2. 내적

- 어차피 a와 b 배열 길이는 같으므로 반복은 1번만 a나 b 길이로 돌리고,
계속해서 a[i]*b[i]결과를 더해나가기

### 3. 소수 만들기

- 3까지는 어차피 예외 케이스이므로 미리 제외시켜주고 소수를 판단하도록 하였음
- 1과 자기자신은 이미 포함되어 있으므로 2부터 나누어주어 소수 판단

- 3개씩 더하므로 처음 시작 인덱스는 길이-3까지, 즉 길이-2는 포함될수 없다
더한 값을 소수인지 판별해서 그 케이스를 카운트

### 4. 완주하지 못한 선수

1) participants와 completion모두 HashMap구조에 담되, 동명이인을 고려해서 <String,Integer>
로 담기

2) participants 중 completion을 확인할 필요가 있어서 participants 행 길이 동안 반복해서
2-1)먼저 키값이 존재하는 지 확인
2-2)키값이 존재하지만 value값이 다르면 동명이인 인원을 채우지 못한 것이라고 간주해서
처리

### 5. K번째 수

예시를 살펴보면 answer의 길이는 commands배열 길이과 같다
그리고 어차피 commands 행길이만큼만 반복해주면 되고, 열 길이가 3으로 그렇게 길지
않아서 [행][0] 이런식으로 접근
1)시작 인덱스와 끝 인덱스를 담을 변수 준비
- 이때 지금 문제와 1이 차이남을 인지
2)시작과 끝의 차이를 이용해서 +1(인덱스 고려) 해서 size에 담기
3)반복될때마다 지역 배열을 size만큼 할당시켜서 진행
4) system.arraycopy로 특정 구간만 복사시키기
5)Arrays.sort의 기본은 asc이므로 이를 이용해서 정렬
6)commands[행][2]-1을 정렬된 배열의 k에 적용해서 k번째 수가져와서 answer배열에 추가

### 6. 모의고사

1) 1번, 2번, 3번 수포자의 패턴은 아래와 같다
        int[] pattern1={1,2,3,4,5};//i%5
        int[] pattern2={2,1,2,3,2,4,2,5};//i%8
        int[] pattern3={3,3,1,1,2,2,4,4,5,5};//i%10
i%~로 한 이유는 우리가 answers.length만큼 배열을 따로 만드는 것보다
`i%길이`로 인덱스만 갈아주는 것이 보다 효율적이라 판단->`one, two, three`

2) 가변적으로 값을 추가하기 위해서 ArrayList사용

3) 수포자 1/2/3 중 한명만이 답을 맞출 수 있는 것이 아니라 if-elseif로 처리하지 않고
if로 케이스를 만들어서 비교하고, 수포자별 정답수를 key-value로 관리하기 위해서
Map<Integer(수포자번호),Integer(맞힌 문제수)>로 관리

4) List<Map.Entry>로 value에 대해서 내림차순 정렬

5) 우선 4)를 기준으로 최댓값인 key를 ArrayList<Integer> answer에 담기

6) 그 다음부터는 최댓값과 같은 경우만   ArrayList<Integer> answer에 담기

### 7. 체육복

1) 전체 학생을 1로 초기화
2) 전체 학생 중 lost에 해당되면 0으로 값 설정
3) 전체 학생 중 reserve에 해당되면 2로 값을 설정하지만, 이전에 0이었더라면
1로 설정
4) 전체 학생을 살펴보면서 체육복이 없는 학생/자기 자신것만 있는 학생/여분이 있는 학생
으로 케이스를 나누고
-체육복이 없는 학생은 앞뒤 학생에게 체육복을 요청
-자기자신것만 있는 학생은 카운트에는 포함될 수 있지만 빌려줄 수는 없음
-여분이 있는 학생은 앞뒤에 학생이 체육복이 없는 경우에 빌려줄 수 있음

### 8. 가장 큰 수

1) String 배열로 int[]배열 옮기기
2) String 배열을 comparator로 o2+o1과 o1+o2를 비교해서 
-o2+o1이 더 크면 바꾸도록 하기
3) 정렬된 배열에서 값을 하나씩 가져와서 answer에 덧붙이기
4) 0이 중복된 경우는 0을 반환


### 9. H-index

1) 배열을 오름차순으로 정렬 ▶ h 편 이상인 경우만 찾으면 그 이하는 확인하지 않아도 됨

2) h=citiations.length-i로 최대의 경우로 가정

3) citiations[i]>=h가 되는 순간을 answer로 하기